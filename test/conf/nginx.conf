worker_processes  1;
events {
    worker_connections  200;
}

daemon off;
master_process off;
error_log   logs/error.log  debug;

http {
    include       mime.types;

    server {
        listen       58081;
        server_name  localhost;

        location / {
            mruby_content_handler_code "Nginx.rputs 'proxy test ok'";
        }
    }

    server {
        listen       58080;
        server_name  localhost;
        root __NGXDOCROOT__;

        # hello world and cache option
        # mruby_*_handler /path/to/file.rb [cache];
        # # http://localhost/mruby
        location /mruby {
            mruby_content_handler build/nginx/html/unified_hello.rb cache;
        }

        # all instance create test
        location /all_instance {
          mruby_content_handler_code '
            if server_name == "NGINX"
              Server = Nginx
            elsif server_name == "Apache"
              Server = Apache
            end

            r = Server::Request.new
            s = Server::Server.new
            c = Server::Connection.new
            v = Server::Var.new

            Server.echo "hostname: " + r.hostname
            Server.echo "path: " + s.path
            Server.echo "hello world"
            Server.echo "documento_root: #{s.document_root}"
            Server.echo "path: #{s.path}"
            Server.echo "remote ip: #{c.remote_ip}"
            Server.echo "remote port: #{c.remote_port}"
            Server.echo "user_agent: #{r.headers_in.user_agent}"
            Server.echo "local ip: #{c.local_ip}"
            Server.echo "local port: #{c.local_port}"
            Server.echo "scheme: #{v.scheme}"

            r.headers_in.all.keys.each do |k|
              Server.echo "#{k}: #{r.headers_in[k]}"
            end
            # if do not raise error, set "OK" into response header
            r.headers_out["X-INST-TEST"] = "OK"
          ';
        }

        # proxy on rewrite phase
        location /proxy {
          mruby_set_code $backend '
            backends = [
              "127.0.0.1:58081",
              #"test2.example.com",
              #"test3.example.com",
            ]
            backends[rand(backends.length)]
          ';
          proxy_pass  http://$backend;
        }

        # include mruby-json
        # http://localhost/
        location / {
            mruby_content_handler_code '
                r = Nginx::Request.new
                r.content_type = "text/html"
                Nginx.rputs "hello ngx_mruby world!<br>"
                Nginx.rputs "content_type: #{r.content_type}<br><br>"
                Nginx.rputs "ngx_mruby_version: #{Nginx.module_version}<br>"
                Nginx.rputs "nginx_version: #{Nginx.nginx_version}<br>"
                Nginx.errlogger Nginx::LOG_ERR, "ngx_mruby error!"
            ';
        }

        # request response header test
        location /header {
            mruby_content_handler_code '
                r = Nginx::Request.new
                unless r.headers_in["X-REQUEST-HEADER"].nil?
                  r.headers_out["X-RESPONSE-HEADER"] = r.headers_in["X-REQUEST-HEADER"]
                  Nginx.rputs "X-REQUEST-HEADER found"
                else
                  r.headers_out["X-RESPONSE-HEADER"] = "nothing"
                  Nginx.rputs "X-REQUEST-HEADER not found"
                end
            ';
        }

        # vars
        # http://localhost/vars?version=hello
        location /vars {
            set $foo "mruby";
            mruby_content_handler_code '
                r = Nginx::Request.new
                r.content_type = "text/html"
                Nginx.rputs "host => #{r.var.host} "
                Nginx.rputs "foo => #{r.var.foo}"
            ';
        }

        # redirect
        # http://localhost/redirect?url=http://www.google.com
        location /redirect {
            mruby_rewrite_handler_code '
                r = Nginx::Request.new
                if r.var.arg_url
                    Nginx.redirect r.var.arg_url
                else
                    Nginx.redirect "http://ngx.mruby.org", 301
                end
            ';
        }

        # internal redirect
        # http://localhost/redirect/internal?version=xxx
        location /redirect/internal {
            mruby_rewrite_handler_code '
                Nginx.redirect "/vars"
            ';
        }

        # output filter by dynamic arg
        location /filter_dynamic_arg {
          mruby_output_filter_code '
            r = Nginx::Request.new
            f = Nginx::Filter.new
            args = r.var.args
            if args.nil?
              f.body = "output filter: static"
            else
              f.body = "output filter: #{args}"
            end
          ';
        }

        # dynamic the internal path for your business
        # http://localhost/redirect/internal/dynamic/path?path=hello
        # actually this request will served by location /static/
        location /redirect/internal/dynamic/path {
            mruby_rewrite_handler_code '
                r = Nginx::Request.new
                dynamic_path = "/static/#{r.var.arg_path}"
                Nginx.redirect dynamic_path
            ';
        }

        # control nginx internal varable between mruby and nginx

        location /inter_var_file {
            set $fuga "200";
            mruby_set $hoge "build/nginx/html/set.rb";
            mruby_content_handler "build/nginx/html/set2.rb";
        }

        location /inter_var_inline {
            set $fuga "100";
            mruby_set_code $hoge 'Nginx::Var.new.fuga.to_i * 2';
            mruby_content_handler_code '
              r = Nginx::Request.new
              Nginx.rputs "fuga => #{r.var.fuga} "
              Nginx.rputs "hoge => #{r.var.hoge} "
              r.var.set "hoge", r.var.hoge.to_i * 2
              Nginx.rputs "hoge => #{r.var.hoge}"
            ';
        }

        location /server_ip_port {
            mruby_content_handler_code '
              c = Nginx::Connection.new
              Nginx.rputs "#{c.local_ip}:#{c.local_port}"
            ';
        }

        location /client_ip {
            mruby_content_handler_code '
              c = Nginx::Connection.new
              Nginx.rputs "#{c.remote_ip}"
            ';
        }

        location ~ \.rb$ {
            mruby_add_handler on;
        }

        location /static/ {
            alias /path/to/static/;
        }

    }
}
